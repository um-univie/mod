#ifndef MOD_CONFIG_HPP
#define MOD_CONFIG_HPP

// rst: .. _libmod-config:
// rst:
// rst: This file defines configuration options for the library.
// rst: Many of the options control verbosity of algorithms or which data to
// rst: output when printing figures.
// rst: 

#include <mod/BuildConfig.hpp>

#include <boost/preprocessor/expand.hpp>
#include <boost/preprocessor/seq/enum.hpp>
#include <boost/preprocessor/seq/for_each.hpp>
#include <boost/preprocessor/seq/for_each_i.hpp>
#include <boost/preprocessor/seq/transform.hpp>
#include <boost/preprocessor/tuple/elem.hpp>

#include <limits>
#include <string>
#include <vector>

namespace mod {
class Config;

// rst: .. enum-struct:: LabelType
// rst:
// rst:		Selector for which type of label to use in algorithms.
// rst:
enum struct LabelType {
	// rst:		.. enumerator:: String
	// rst:
	// rst:			Vertices and edges are considered to be labelled with
	// rst:			character strings. If only first-order terms are present,
	// rst:			then strings are generated as a serialisation of the term.
	String,
	// rst:		.. enumerator:: Term
	// rst:
	// rst:			Vertices and edges are considered to be labelled with
	// rst:			first-order terms. If only strings are present, then first-order
	// rst:			terms are generated by parsing the strings. This may result
	// rst:			in an :cpp:class:`TermParsingError` if a string can not be parsed.
	Term
};
MOD_DECL std::ostream &operator<<(std::ostream &s, LabelType lt);

// rst: .. enum-struct:: LabelRelation
// rst:
// rst:		Selector for which type of labelled morphism to use in an algorithm.
// rst:
enum class LabelRelation {
	// rst:		.. enumerator:: Isomorphism
	// rst:
	// rst:			Strings are considered isomorphic when they are equal.
	// rst:			Terms are considered isomorphic when their most general unifier
	// rst:			is a renaming.
	Isomorphism,
	// rst:		.. enumerator:: Specialisation
	// rst:
	// rst:			A term :math:`t_2` is more special than, or isomorphic to, a term :math:`t_1` if there is a substitution
	// rst:			which can be applied to :math:`t_1` to make the terms equal.
	// rst:			This relation means that the right-hand side of a comparison is the more specialised term.
	Specialisation,
	// rst:		.. enumerator:: Unification
	// rst:
	// rst:			Strings unify if they are equal, i.e., the same as with :cpp:any:`Isomorphism`.
	// rst:			Terms unify if a most general unifier (MGU) exists. The found MGU
	// rst:			is used for substitution in some algorithms.
	Unification
};
MOD_DECL std::ostream &operator<<(std::ostream &s, LabelRelation lt);

// rst: .. class:: LabelSettings
// rst:
// rst:		A class simply for grouping label settings.
// rst:
struct LabelSettings {
	// rst:		.. function:: LabelSettings(LabelType type, LabelRelation relation)
	// rst:
	// rst:			Construct label settings that only uses the vertex and edge labels.
	LabelSettings(LabelType type, LabelRelation relation)
			: LabelSettings(type, relation, false, LabelRelation::Isomorphism) {}

	// rst:		.. function:: LabelSettings(LabelType type, LabelRelation relation, LabelRelation stereoRelation)
	// rst:
	// rst:			Construct label settings that include both vertex and edge labels, and stereo information.
	LabelSettings(LabelType type, LabelRelation relation, LabelRelation stereoRelation)
			: LabelSettings(type, relation, true, stereoRelation) {}

	// rst:		.. function:: LabelSettings(LabelType type, LabelRelation relation, bool withStereo, LabelRelation stereoRelation)
	LabelSettings(LabelType type, LabelRelation relation, bool withStereo, LabelRelation stereoRelation)
			: type(type), relation(relation), withStereo(withStereo), stereoRelation(stereoRelation) {}

	// rst:		.. function:: friend bool operator==(LabelSettings a, LabelSettings b)
	// rst:		              friend bool operator!=(LabelSettings a, LabelSettings b)
	MOD_DECL friend bool operator==(LabelSettings a, LabelSettings b);
	MOD_DECL friend bool operator!=(LabelSettings a, LabelSettings b);
	// rst:		.. function:: friend std::ostream &operator<<(std::ostream &s, const LabelSettings &ls)
	MOD_DECL friend std::ostream &operator<<(std::ostream &s, LabelSettings ls);
public:
	// rst:		.. member:: LabelType type
	LabelType type;
	// rst:		.. member:: LabelRelation relation
	LabelRelation relation;
	// rst:		.. member:: bool withStereo
	bool withStereo;
	// rst:		.. member:: LabelRelation stereoRelation
	LabelRelation stereoRelation;
};

// rst: ..  enum-struct:: IsomorphismPolicy
// rst:
// rst:		For some functions there is a choice of how to handle given arguments
// rst:		where two different objects may be isomorphic. Most notably the case is with graphs (:class:`graph::Graph`).
// rst:
enum class IsomorphismPolicy {
	// rst:		.. enumerator:: Check
	// rst:
	// rst:			Objects are checked for isomorphism as needed and exceptions are thrown when different objects are isomorphic.
	// rst:			If in doubt, use this.
	Check,
	// rst:		.. enumerator:: TrustMe
	// rst:
	// rst:			No checks are performed and the function trusts the caller to have performed the equivalent isomorphism checks.
	// rst:			Only use this when you are completely sure that no exceptions would have been thrown if using :enumerator:`Check`.
	// rst:
	// rst:			.. warning:: Generally the library has undefined behaviour if you use this option
	// rst:				but an exception would have been thrown with :enumerator:`Check`.
	TrustMe
};
MOD_DECL std::ostream &operator<<(std::ostream &s, IsomorphismPolicy p);

// rst: .. enum-struct:: SmilesClassPolicy
// rst:
// rst:		When loading SMILES strings, the class labels can be recorded and mapped into the corresponding
// rst:		vertices of the loaded graph. This policy dictates what should happen when the same class label
// rst:		is written on multiple atoms.
// rst:
enum class SmilesClassPolicy {
	// rst:		.. enumerator:: NoneOnDuplicate
	// rst:
	// rst:			If a class label is duplicated, then no labels are mapped to vertices.
	NoneOnDuplicate,
	// rst:		.. enumerator:: ThrowOnDuplicate
	// rst:
	// rst:			If a class label is duplicated, throw a :class:`InputError`.
	ThrowOnDuplicate,
	// rst:		.. enumerator:: MapUnique
	// rst:
	// rst:			Map all class labels that are unique to vertices.
	MapUnique
};
MOD_DECL std::ostream &operator<<(std::ostream &s, SmilesClassPolicy p);

// rst: .. enum-struct:: Action
// rst:
// rst:		Utility enum for deciding what to do in certain cases.
// rst:
enum class Action {
	// rst:		.. enumerator:: Error
	// rst:
	// rst:			Abort the function and produce an error message, e.g., through and exception.
	Error,
	// rst:		.. enumerator:: Warn
	// rst:
	// rst:			Write a warning, but otherwise do as if it was `Ignore`.
	Warn,
	// rst:		.. enumerator:: Ignore
	// rst:
	// rst:			Ignore the case. The function taking the action as argument should describe what this means.
	Ignore
};
MOD_DECL std::ostream &operator<<(std::ostream &s, Action a);

// rst: .. class:: MDLOptions
// rst:
// rst:		An aggregation of options for the various loading functions for MDL formats.
// rst:		Generally each option is defaulted to follow the specification of the formats,
// rst:		unless it is harmless to deviate (e.g., relaxed white-space parsing).
// rst:
struct MOD_DECL MDLOptions {
	// rst:		.. member:: bool addHydrogens = true
	// rst:
	// rst:			Use the MDL valence model to add hydrogens to atoms with default valence, or disable all hydrogen addition.
	bool addHydrogens = true;
	// rst:		.. member:: bool allowAbstract = false
	// rst:
	// rst:			Allow non-standard atom symbols. The standard symbols are the element symbols and those specifying wildcard atoms.
	bool allowAbstract = false;
	// rst:		.. member:: bool applyV2000AtomAliases = true
	// rst:
	// rst:			In MOL V2000 CTAB blocks, replace atom labels by their aliases.
	// rst:			After application, the atom is considered abstract without errors, and hydrogen addition is suppressed.
	bool applyV2000AtomAliases = true;
	// rst:		.. member:: Action onPatternIsotope = Action::Error
	// rst:		            Action onPatternCharge = Action::Error;
	// rst:		            Action onPatternRadical = Action::Error;
	// rst:
	// rst:			What to do when an atom with symbol ``*`` has an isotope, charge, or radical.
	// rst:			`Action::Ignore` means assuming the isotope, charge, or radical was not there.
	Action onPatternIsotope = Action::Error;
	Action onPatternCharge = Action::Error;
	Action onPatternRadical = Action::Error;
	// rst:		.. member:: Action onImplicitValenceOnAbstract = Action::Error
	// rst:
	// rst:			What to do when `addHydrogens && allowAbstract` and an abstract atom is encountered with implicit valence.
	// rst:			`Action::Ignore` means adding no hydrogens.
	Action onImplicitValenceOnAbstract = Action::Error;
	// rst:		.. member:: Action onV2000UnhandledProperty = Action::Warn
	// rst:
	// rst:			What to do when a property line in a V2000 MOL file is not recognized.
	// rst:			`Action::Ignore` means simply ignoring that particular line.
	Action onV2000UnhandledProperty = Action::Warn;
	// rst:		.. member:: bool fullyIgnoreV2000UnhandledKnownProperty = false
	// rst:
	// rst:			Warnings are usually stored as "loading warnings", even when they are ignored during parsing.
	// rst:			Setting this to `true` will act as if `onV2000UnhandledProperty = Action::Ignore` and
	// rst:			skip the storage, but only for a pre-defined known subset of properties.
	bool fullyIgnoreV2000UnhandledKnownProperty = false;
	// rst:		.. member:: Action onV3000UnhandledAtomProperty = Action::Warn
	// rst:
	// rst:			What to do when a property in atom line in a V3000 MOL file is not recognized.
	// rst:			`Action::Ignore` means simply ignoring that particular property.
	Action onV3000UnhandledAtomProperty = Action::Warn;
	// rst:		.. member:: Action onV2000Charge4 = Action::Error
	// rst:
	// rst:			What to do when an atom in a V2000 MOL file has the charge 4 (doublet radical).
	// rst:			`Action::Ignore` means assuming it was charge 0.
	Action onV2000Charge4 = Action::Error;
	// rst:		.. member:: Action onV2000AbstractISO = Action::Error
	// rst:
	// rst:			What to do when an abstract atom in a V2000 MOL file has a non-default ISO or mass difference value.
	//	rst:			`Action::Ignore` means assuming it had no ISO or mass difference value.
	Action onV2000AbstractISO = Action::Error;
	// rst:		.. member:: Action onRAD1 = Action::Error
	// rst:		            Action onRAD3 = Action::Error
	// rst:		            Action onRAD4 = Action::Error
	// rst:		            Action onRAD5 = Action::Error
	// rst:		            Action onRAD6 = Action::Error
	// rst:
	// rst:			What to do when an atom has assigned the indicated radical state.
	// rst:			`Action::Ignore` means pretending the atom has no radical state assigned.
	Action onRAD1 = Action::Error;
	Action onRAD3 = Action::Error;
	Action onRAD4 = Action::Error;
	Action onRAD5 = Action::Error;
	Action onRAD6 = Action::Error;
	// rst:		.. member:: Action onUnsupportedQueryBondType = Action::Error
	// rst:
	// rst:			What to do when a bond type 5, 6, or 7 are encountered (constrained query bond types).
	// rst:			`Action::Ignore` means assigning a term variable, as if the type was 8.
	Action onUnsupportedQueryBondType = Action::Error;
};

// rst: .. function:: Config &getConfig()
// rst: 
// rst:		:returns: the singleton :cpp:class:`Config` instance used by the library.
// rst:
MOD_DECL Config &getConfig();

// rst-class: template<typename T> ConfigSetting
// rst: 
// rst:		Holds a single option of type :cpp:any:`T`.
// rst-class-start:

template<typename T>
struct ConfigSetting {
	ConfigSetting(T value, const std::string &name) : value(value), name(name) {}

	// rst: .. function:: void set(T value)
	// rst:
	// rst:		Sets the configuration value.
	// rst:
	void set(T value) {
		this->value = value;
	};

	// rst: .. function:: T get() const
	// rst:
	// rst:		:returns: The configuration value.
	// rst:
	T get() const {
		return value;
	}

	// rst: .. function: T &operator()()
	// rst:
	// rst:		Access the value.
	// rst:
	T &operator()() {
		return value;
	}

	const std::string &getName() const {
		return name;
	}
private:
	T value;
	const std::string name;
};
// rst-class-end:

// rst-class: Config
// rst:
// rst:		Holds all configuration settings.
// rst:
// rst-class-end:
struct Config {
	enum class IsomorphismAlg {
		VF2, Canon, SmilesCanonVF2
	};

	Config() = default;
	Config(Config &&) = delete;
	Config &operator=(Config &&) = delete;

// BOOST_PP_SEQ(
//	BOOST_PP_TUPLE(NamespaceClass, NamespaceName,
//		BOOST_PP_SEQ(
//			BOOST_PP_TUPLE(Type, Name, DefaultValue)
//		)
//	)
// )

#define MOD_CONFIG_DATA_NS_SIZE() 3
#define MOD_CONFIG_DATA_SETTING_SIZE() 3
#define MOD_CONFIG_DATA()                                                           \
    /* rst: .. todo:: write documentation for all settings */                       \
    ((Canon, canon,                                                                 \
        ((bool, printStats, false))                                                 \
    ))                                                                              \
    ((Common, common,                                                               \
        ((bool, quiet, false))                                                      \
        ((bool, ignoreDeprecation, true))                                           \
        ((unsigned int, numThreads, 1))                                             \
    ))                                                                              \
    ((DG, dg,                                                                       \
        ((bool, useOldRuleApplication, false))                                      \
        ((bool, calculateVerbosePrint, false))                                      \
        ((bool, putAllProductsInSubset, false))                                     \
        ((bool, dryDerivationPrinting, false))                                      \
        ((bool, derivationDebugOutput, false))                                      \
        ((bool, disableRepeatFixedPointCheck, false))                               \
        ((int, derivationVerbosity, 0))                                             \
        ((bool, applyAssumeConfluence, false))                                      \
        ((int, applyLimit, -1))                                                     \
    ))                                                                              \
    ((Graph, graph,                                                                 \
        ((bool, smilesCheckAST, false))                                             \
        ((bool, ignoreStereoInSmiles, false))                                       \
        ((bool, printSmilesParsingWarnings, true))                                  \
        ((bool, appendSmilesClass, false))                                          \
        ((mod::Config::IsomorphismAlg, isomorphismAlg, mod::Config::IsomorphismAlg::VF2)) \
        ((bool, useWrongSmilesCanonAlg, false))                                     \
        ((bool, checkIsoInPermutation, false))                                      \
        ((unsigned long, numIsomorphismCalls, 0))                                   \
    ))                                                                              \
    ((Rule, rule,                                                                   \
        ((bool, ignoreConstraintsDuringInversion, false))                           \
        ((std::string, changeColourL, "NavyBlue"))                                  \
        ((std::string, changeColourK, "Purple"))                                    \
        ((std::string, changeColourR, "Green"))                                     \
        ((bool, printChangedEdgesInContext, false))                                 \
        ((bool, collapseChangedHydrogens, false))                                   \
    ))                                                                              \
    ((RC, rc,                                                                       \
        ((bool, composeConstraints, true))                                          \
        ((bool, printMatches, false))                                               \
        ((bool, matchesWithIndex, false))                                           \
        ((bool, printMatchesOnlyHaxChem, false))                                    \
        ((int, componentWiseMorphismLimit, 0))                                      \
        ((bool, useBoostCommonSubgraph, false))                                     \
    ))                                                                              \
    ((Stereo, stereo,                                                               \
        ((bool, silenceDeductionWarnings, false))                                   \
    ))

#define MOD_CONFIG_nsIter(rNS, dataNS, tNS)                                           \
    struct BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS) {                   \
        using Self = BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS);          \
        BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS)(const Self&) = delete; \
        Self &operator=(const Self&) = delete;                                        \
        BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS)(Self&&) = delete;      \
        Self &operator=(Self&&) = delete;                                             \
        inline BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS)() :             \
        BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM(MOD_CONFIG_settingIterCons,          \
            BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS),                   \
            BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 2, tNS))                   \
        ) {}                                                                          \
        BOOST_PP_SEQ_FOR_EACH_I(MOD_CONFIG_settingIter,                               \
            BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 0, tNS),                   \
            BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 2, tNS))                   \
    } BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_NS_SIZE(), 1, tNS);

#define MOD_CONFIG_settingIterCons(rSettting, dataSetting, tSetting)                                    \
    BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 1, tSetting)(                                   \
        BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 2, tSetting),                               \
        MOD_toString(dataSetting) "::"                                                                  \
        MOD_toString(BOOST_PP_EXPAND(BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 1, tSetting))) \
    )

#define MOD_CONFIG_settingIter(rSettting, dataSetting, nSetting, tSetting)          \
    ConfigSetting<BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 0, tSetting)> \
        BOOST_PP_TUPLE_ELEM(MOD_CONFIG_DATA_SETTING_SIZE(), 1, tSetting);

#define MOD_toString(s) MOD_toString1(s)
#define MOD_toString1(s) #s

BOOST_PP_SEQ_FOR_EACH(MOD_CONFIG_nsIter, ~, MOD_CONFIG_DATA())

#undef MOD_CONFIG_settingIterCons
#undef MOD_CONFIG_settingIter
#undef MOD_CONFIG_nsIter
};

} // namespace mod

#endif // MOD_CONFIG_HPP